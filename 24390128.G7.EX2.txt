#
#Εργαστήριο ΛΣ1
# Ονοματεπώνυμο : Μανώλακας Βασίλειος
# ΑΜ : 24390128
#
#
#
# Ερώτημα 1. Searching
#
#
# Το script λειτουργεί μόνο αν δοθούν 2 ακέραιοι παράμετροι, όπως υπαγορεύει η εκφώνηση. Αν αυτό δεν ισχύει, το script τερματίζει μετά την #εκτύπωση κατάλληλων μηνυμάτων . Στην συνέχεια ελέγχεται αν το πρώτο όρισμα αποτελεί οκταδικό  permission. Δηλαδή ελέγχεται αν το πρώτο όρισμα #αποτελείται ΜΟΝΟ από ψηφία 0-7, τα οποία στο πλήθος μπορεί να είναι 3 ή 4. Σε κλασικές περιπτώσεις τα ψηφία είναι 3, ωστόσο μπορεί να υπάρχει #special bit ΜΠΡΟΣΤΑ από τον οκταδικό, π.χ. permission 4755 , special bit = 4.
#Υπάρχουν τα bits : SUID, SGID, sticky. Οπότε το script τα λαμβάνει και αυτά υπ' όψην.
#Έπειτα ελέγχεται αν το δεύτερο όρισμα (δηλαδή ο αριθμός ημερών) είναι έγκυρος. Δηλαδή ελέγχεται αν ο αριθμός είναι x-ψήφιος και αποτελείται ΜΟΝΟ #από ψηφία 0-9. Αν αυτό δεν ισχύει, το δεύτερο όρισμα δεν είναι έγκυρος αριθμός ημερών και τερματίζουμε.
#
# Στην συνέχεια εκτυπώνεται ο αριθμός των παραμέτρων στο τερματικό για να φαίνεται η ορθότητα των ορισμάτων που δόθηκαν.
# Έπειτα έχουμε αρχικοποίηση 5 μετρητών με την τιμή 0. Οι πέντε αυτοί μετρητές (c1..c5) εμφανίζουν το πλήθος των αρχείων ή καταλόγων που έχουν #κάθε μία από τις ιδιότητες 1...5 που περιγράφονται στην εκφώνηση. Για παράδειγμα, ο μετρητής c1 δείχνει πόσα αρχεία έχουν την ιδιότητα 1, δηλαδή #είναι τα αρχεία που έχουν ως permissions το πρώτο όρισμα που δόθηκε στο script.
#
#Έπειτα ανοίγει ένας επαναληπτικός βρόχος while, ο οποίος υλοποιεί το ζητούμενο "Το script να εκτελείται
#επαναληπτικά όσο επιθυμεί ο χρήστης". Στην αρχή του βρόχου ζητείται από τον χρήστη να εισάγει έναν κατάλογο, ο οποίος αποθηκεύεται στην #μεταβλητή $directory. Αν ο χρήστης εισάγει το γράμμα 'q' τότε $directory == "q" και ο βρόχος τερματίζεται και εμφανίζονται οι μετρητές c1...c5 #με κατάλληά μηνύματα. Διαφορετικά, ο βρόχος προχωρά, ώστε στη συνέχεια να ελεγχθεί η εγκυρότητα του δοθέντος καταλόγου.
#
# Σε επόμενο στάδιο ελέγχεται αν ο κατάλογος που έχει αποθηκευθεί στην μεταβλητή directory υπάρχει, με το prefix -d. Αν ο κατάλογος δεν υπάρχει, #εμφανίζεται κατάλληλο μήνυμα και το script τερματίζει.
#
#Για κάθε περίπτωση (1-5) της εκφώνησης, εκτελούνται οι παρακάτω εντολές, και η έξοδός τους εκχωρείται στις μεταβλητές #command_output_1...command_output_5.
#
#Περίπτωση 1:
#Να εκτυπώνονται, με find:
#    Τα αρχεία του δέντρου του δοθέντος καταλόγου με εξουσιοδοτήσεις
#    (permissions) τον πρώτο αριθμό (όρισμα) θεωρώντας τον ως οκταδικό
#    ισοδύναμο.
#
#Λύση: εκτελούμε find στο συγκεκριμένο κατάλογο της μεταβλητής directory , ψάχνοντας για αρχεία με επιλογή -type f. Επίσης θέλουμε
#το πρώτο όρισμα να αποτελεί permission. Το πρώτο όρισμα αποθηκεύεται στην positional παράμετρο $1, άρα ελέγχουμε για -perm "$1". (η επιλογή
#
# -perm) αποτελεί δυνατότητα της find, η οποία ελέγχει αν τα permission bits του αρχείου είναι ακριβώς το περιεχόμενο της μεταβλητής $1. Τέλος, #
#θέλουμε να εκτυπώσουμε όλα αυτά τα αρχεία όπως ζητά η εκφώνηση, άρα χρησιμοποιούμε την επιλογή -print της find. Άρα η τελική εντολή είναι η :
#
#find "$directory" -type f -perm "$1" -print
#
#Ωστόσο η εκφώνηση ζητά, πως πριν την εκτύπωση των δεδομένων, πρέπει να εμφανίζεται ο αριθμός των αρχείων ή υποκαταλόγων που πρέπει να #εκτυπωθούν. Οπότε η έξοδος της παραπάνω εντολής (και κάθε εντολής εφεξής) θα αποθηκεύεται σε μια μεταβλητή πρώτα, και συγκεκριμένα στις #μεταβλητές command_output_1...command_output_5. Για να βρεθεί ο αριθμός αρχείων στέλνουμε το περιεχόμενο της μεταβλητής $command_output_1 σε #grep -c . μετρώντας τις μη κενές γραμμές.
#Τέλος, ενημερώνεται ο συνολικός μετρητής c1 με (( c1 += command_counter_1 )), ώστε να βγει το συνολικό άθροισμα στο τέλος για όλα τα files που #έψαξε ο χρήστης.
#
# Περίπτωση 2:
#Να εκτυπώνονται, με find:
#    Τα αρχεία του δέντρου του δοθέντος καταλόγου που άλλαξαν (modify)
#    περιεχόμενα κατά τις ‘x’ τελευταίες μέρες, όπου ‘x’ ο δεύτερος αριθμός
#    (όρισμα).
#
#Λύση: εκτελούμε find στο συγκεκριμένο κατάλογο της μεταβλητής directory, ψάχνοντας πάλι για αρχεία με επιλογή -type f, όπως και στην περίπτωση #1. Όμως τώρα δεν μας ενδιαφέρει το permission, αλλά ο χρόνος τελευταίας τροποποίησης (mtime). Το δεύτερο όρισμα είναι ο αριθμός ημερών και #αποθηκεύεται στην positional παράμετρο $2. Άρα χρησιμοποιούμε την επιλογή -mtime -"${2}" η οποία σημαίνει “αρχεία που έχουν τροποποιηθεί τις #τελευταίες x μέρες”. Τέλος, επειδή θέλουμε να τυπώσουμε τα αποτελέσματα, χρησιμοποιούμε -print. Άρα η τελική εντολή είναι η :
#
#find "$directory" -type f -mtime -"${2}" -print
#
#Όπως και στην περίπτωση 1, η εκφώνηση ζητά πριν την εκτύπωση να εμφανίζεται ο αριθμός των αρχείων που θα τυπωθούν. Οπότε αποθηκεύουμε την έξοδο #της εντολής στη μεταβλητή command_output_2. Έπειτα, για να μετρήσουμε πόσες γραμμές/αρχεία υπάρχουν μέσα σε αυτήν, χρησιμοποιούμε printf για να #τυπωθεί το περιεχόμενο γραμμή-γραμμή και το στέλνουμε σε grep -c . ώστε να μετρηθούν οι μη κενές γραμμές. Αυτό το πλήθος αποθηκεύεται στη #μεταβλητή command_counter_2 και εμφανίζεται στην επικεφαλίδα, και μετά γίνεται η εκτύπωση της λίστας. Τέλος, ενημερώνεται ο συνολικός μετρητής #c2 με (( c2 += command_counter_2 )), ώστε να βγει το συνολικό άθροισμα στο τέλος για όλα τα directories που έψαξε ο χρήστης.
#
# Περίπτωση 3:
#Να εκτυπώνονται, με find:
#    Τους υποκαταλόγους του δέντρου του δοθέντος καταλόγου που
#    προσπελάστηκαν (access) κατά τις ‘x’ τελευταίες μέρες, όπου ‘x’ ο δεύτερος
#    αριθμός (όρισμα).
#
#Λύση: εκτελούμε find στο συγκεκριμένο κατάλογο της μεταβλητής directory, όμως εδώ δεν ψάχνουμε για αρχεία αλλά για καταλόγους. Άρα #χρησιμοποιούμε -type d. Επίσης, η εκφώνηση ζητά πρόσβαση (access), άρα χρησιμοποιούμε -atime -"${2}" όπου το $2 είναι ο αριθμός ημερών, και αυτό #σημαίνει “κατάλογοι που προσπελάστηκαν τις τελευταίες x μέρες”. Τέλος, για να εμφανιστούν τα αποτελέσματα χρησιμοποιούμε -print. Άρα η τελική #εντολή είναι η :
#
#find "$directory" -type d -atime -"${2}" -print
#
#Όπως και στις προηγούμενες περιπτώσεις, αποθηκεύουμε την έξοδο στη μεταβλητή command_output_3, μετράμε πόσα αποτελέσματα υπάρχουν με grep -c . #και το αποθηκεύουμε σε command_counter_3, τυπώνουμε πρώτα την επικεφαλίδα με το πλήθος (directories) και μετά τυπώνουμε τη λίστα. Τέλος, #προσθέτουμε το πλήθος στον συνολικό μετρητή c3 με (( c3 += command_counter_3 )), ώστε να βγει συνολικό άθροισμα στο τέλος για όλα τα directories #που έψαξε ο χρήστης.
#
# Περίπτωση 4:
#Να εκτυπώνονται, με συνδυασμό ls και grep:
#    Τα αρχεία του δοθέντος καταλόγου στα οποία έχουν δικαίωμα ανάγνωσης
#    όλοι οι χρήστες.
#
#Λύση: εδώ η εκφώνηση ζητά να χρησιμοποιήσουμε ls και grep, και επίσης δεν αναφέρεται στο “δέντρο” αλλά στον ίδιο τον δοθέντα κατάλογο. Άρα #χρησιμοποιούμε ls -l "$directory" ώστε να πάρουμε long listing και να φαίνεται το permission string στην αρχή κάθε γραμμής (π.χ. -rw-r--r-- ή
#-rwxr-xr-x). Στην συνέχεια φιλτράρουμε με grep -E ένα pattern που να διασφαλίζει ότι πρόκειται για αρχείο (δηλαδή να ξεκινάει με '-') και ότι #τόσο ο owner όσο και το group και οι others έχουν read. Το pattern που χρησιμοποιείται στο script είναι:
#
#ls -l "$directory" | grep -E '^-r..r..r..'
#
#Η έξοδος αποθηκεύεται στη μεταβλητή command_output_4. Μετράμε τις γραμμές/αρχεία με grep -c . και το αποθηκεύουμε σε command_counter_4, #τυπώνουμε την επικεφαλίδα με το πλήθος των αρχείων που θα εμφανιστούν, και μετά τυπώνουμε τη λίστα. Τέλος, αθροίζουμε το πλήθος στον συνολικό #μετρητή c4 με (( c4 += command_counter_4 )), ώστε να έχουμε στο τέλος το συνολικό πλήθος αρχείων (από όλους τους καταλόγους) που έχουν read για #όλους τους χρήστες.
#
# Περίπτωση 5:
#Να εκτυπώνονται, με συνδυασμό ls και grep:
#    Τους υποκαταλόγους του δοθέντος καταλόγου στους οποίους έχουν
#    δικαίωμα αλλαγών (create/rename/delete files) εκτός από τον ιδιοκτήτη και
#    άλλοι χρήστες του συστήματος.
#
#Λύση: εδώ μιλάμε για υποκαταλόγους του δοθέντος καταλόγου, άρα πάλι χρησιμοποιούμε ls -l "$directory". Η “δυνατότητα αλλαγών” σε κατάλογο #(create/rename/delete files) πρακτικά σημαίνει να υπάρχει δικαίωμα write και execute στον κατάλογο, όχι μόνο για τον ιδιοκτήτη αλλά και για #group #ή/και others. Για να βρούμε τέτοιους καταλόγους, φιλτράρουμε γραμμές που ξεκινάνε με 'd' (directory) και μετά ταιριάζουμε τα permission #bits ώστε #να εντοπίζουμε περιπτώσεις που το group έχει w και x (ή s), ή εναλλακτικά οι others έχουν w και x (ή t). Το pattern που #χρησιμοποιείται στο #script είναι:
#
#ls -l "$directory" | grep -E '^(d....w[xs]...|d.......w[xt])'
#
#Το πρώτο μέρος (d....w[xs]...) πιάνει directories όπου στην περιοχή των group permissions υπάρχει write (w) και execute (x ή s). Το δεύτερο #μέρος (d.......w[xt]) πιάνει directories όπου στην περιοχή των others permissions υπάρχει write (w) και execute (x ή t). Άρα υλοποιείται το #ζητούμενο: “εκτός από τον ιδιοκτήτη και άλλοι χρήστες του συστήματος” να μπορούν να κάνουν αλλαγές.
#
#Η έξοδος αποθηκεύεται στη μεταβλητή command_output_5, το πλήθος γραμμών/καταλόγων μετριέται με grep -c . και αποθηκεύεται στη μεταβλητή #command_counter_5, τυπώνεται πρώτα η επικεφαλίδα με το πλήθος των directories που θα εμφανιστούν, και μετά τυπώνεται η λίστα. Τέλος, γίνεται #αθροιστική πρόσθεση στον μετρητή c5 με (( c5 += command_counter_5 )), ώστε στο τέλος να εμφανιστεί το συνολικό πλήθος υποκαταλόγων (από όλους #τους καταλόγους στους οποίους έψαξε ο χρήστης) που επιτρέπουν αλλαγές σε group ή/και others.
#
# Τελική έξοδος (αθροιστικά αποτελέσματα):
#Μετά την έξοδο από τον βρόχο while (δηλαδή όταν ο χρήστης δώσει 'q'), τυπώνονται οι γραμμές “Case 1 … Case 5 …” όπου εμφανίζονται οι τελικές #τιμές των μετρητών c1..c5. Αυτό υλοποιεί ακριβώς το ζητούμενο της εκφώνησης: “στο τέλος (πριν την τελική έξοδο) να εμφανίζει αθροιστικά το #συνολικό αριθμό των ευρεθέντων (αρχείων / υποκαταλόγων) κάθε περίπτωσης (1 έως 5) για όλους τους καταλόγους στους οποίους έψαξε.”
#
#
# Ακολουθεί το script 1 : searching...
#!/bin/bash

printf "\n"
echo "--- Script 1: Searching ---"
printf "\n"

if (( $# != 2 )); then
echo "Two arguments must be given, or else the script will not run."
printf "\n"
echo "For integer arguments x and y, make sure that the script is executed as : ./searching.sh x y"
exit 1
fi

if ! [[ "$1" =~ ^-?[0-9]+$ ]] || ! [[ "$2" =~ ^-?[0-9]+$ ]]; then
  echo "Both parameters must be integers."
  exit 1
fi

if ! [[ "$1" =~ ^[0-7]{3,4}$ ]]; then
echo "$1" is not an octal permission value. Exiting...
exit 1
fi

if ! [[ "$2" =~ ^[0-9]+$ ]]; then
echo "$2" is not a valid number for days. Exiting...
exit 1
fi

echo Integer Parameter 1 is : $1
echo Integer Parameter 2 is : $2
echo

c1=0;c2=0;c3=0;c4=0;c5=0;

while :
do
read -r -p 'Directory (Press q to quit): '  directory
if [[ "$directory" == "q" ]]; then
printf "\n"
echo Exiting...
break
fi
if [[ ! -d "$directory" ]]; then
echo
echo "$directory" is not a directory. Try again :
echo
continue
fi
echo Searching $directory...
echo
#1
command_output_1=$(find "$directory" -type f -perm "$1" -print)
command_count_1=$(printf '%s\n' "$command_output_1" | grep -c .)
echo "$command_count_1 files will be printed for question 1."
echo
printf '%s\n' "$command_output_1"
(( c1 += command_count_1 ))

#2
command_output_2=$(find "$directory" -type f -mtime -"${2}" -print)
command_counter_2=$(printf '%s\n' "$command_output_2" | grep -c .)
echo "$command_counter_2 files will be printed for question 2."
echo
printf '%s\n' "$command_output_2"
(( c2 += command_counter_2 ))
#3
command_output_3=$(find "$directory" -type d -atime -"${2}" -print)
command_counter_3=$(printf '%s\n' "$command_output_3" | grep -c .)
echo "$command_counter_3 directories will be printed for question 3."
echo
printf '%s\n' "$command_output_3"
(( c3 += command_counter_3 ))

#4
command_output_4=$(ls -l "$directory" | grep -E '^-r..r..r..')
command_counter_4=$(printf '%s\n' "$command_output_4" | grep -c .)
echo "$command_counter_4 files will be printed for question 4."
echo
printf '%s\n' "$command_output_4"
(( c4 += command_counter_4 ))
#5
command_output_5=$(ls -l "$directory" | grep -E '^(d....w[xs]...|d.......w[xt])')
command_counter_5=$(printf '%s\n' "$command_output_5" | grep -c .)
echo "$command_counter_5 directories will be printed for question 5."
echo
printf '%s\n' "$command_output_5"
(( c5 += command_counter_5 ))

done

echo Case 1: $c1 tree files had octal right "$1".
echo Case 2: $c2 tree files have been modified the last "$2" days.
echo Case 3: $c3 subdirectories have been accessed in the last "$2" days.
echo Case 4: $c4 files grant read rights to all users.
echo "Case 5: $c5 subdirectories allow write/execute to group or others (not only the owner)".

